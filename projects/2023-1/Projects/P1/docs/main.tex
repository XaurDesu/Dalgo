\documentclass[a4paper]{article} 
\input{head}
\begin{document}

%-------------------------------
%	TITLE SECTION
%-------------------------------

\fancyhead[C]{}
\hrule \medskip % Upper rule
\begin{minipage}{0.295\textwidth} 
\raggedright
\footnotesize
Jaime Andres Torres Bermejo \hfill\\   
202014866\hfill\\
andrestbermejoj@gmail.com
\end{minipage}
\begin{minipage}{0.4\textwidth} 
\centering 
\large 
Proyecto 1\\ 
\normalsize 
Diseño y Análisis de Algoritmos\\ 
\end{minipage}
\begin{minipage}{0.295\textwidth} 
\raggedleft
\today\hfill\\
\end{minipage}
\medskip\hrule 
\bigskip

%-------------------------------
%	CONTENIDO
%-------------------------------
\section{Enunciado del Proyecto}

Uno de los principales retos de la reforma a la salud 2023 propuesta por el gobierno actual son los
denominados Centros de Atención Primaria (CAD). A cada CAD en el país serán asignados los
beneficiarios y sus familias según cercanía y disponibilidad. Para que las finanzas de estos centros
no se vean afectadas por una mala distribución de beneficiarios y para garantizar el mejor servicio,
es necesario diseñar una estrategia de asignación equitativa de beneficiarios.

\paragraph{Problema:}
Suponga que para un atender la demanda de salud en un determinado municipio de Colombia se
habilitaran \textit{k} diferentes CADs a los cuales se deberán asignar \textit{m} familias diferentes. La familia i-
esima cuenta con \textit{$f_i$} miembros diferentes. Se le encarga la tarea de identificar si existe una manera
en que todos los CAD puedan quedar con la misma cantidad de beneficiarios, con la restricción que
TODOS los miembros de un mismo grupo familiar sean asignados a un mismo CAD. [1]

%------------------------------------------------
\section{Especificaciones del proyecto}

\subsection{Entorno de Desarrollo y entorno de prueba.}

La solución propuesta fue probada en el siguiente entorno de Desarrollo, debería funcionar en
computadores que compartan las dependencias principales, como Python o un sistema operativo basado
en Unix, así no comparta necesariamente el hardware. No se proporciona un entorno de virtualización
por lo que recomiendo intentar correrlo en un entorno relativamente similar.

\begin{itemize}
    \item \textbf{Sistema Operativo: } Ubuntu 22.10 x86\_64, Minimal Install.
    \item \textbf{Kernel: }Linux 5.19.0-38-generic
    \item \textbf{Lenguaje de Programación: }Python 3.10.7 x86\_64, Compilado desde apt como un .deb, incluye python3-pip
    \item \textbf{Librerías Utilizadas}
    \begin{itemize}
        \item os
    \end{itemize}
    \item \textbf{Procesador: }AMD Ryzen 5 3550H with Radeon Vega Mobile Gfx (8) @ 2.100GHz 
    \item \textbf{IDE: } Visual Studio Code 1.76.2, instalado desde un paquete snapd. Incluye extensiones
    de Git y Python.
\end{itemize}

\subsection{Estructura del Input y Output}
A primera vista, este pareciese ser un problema bastante extraño, si fuesemos a tomarlo por la lógica
del propio problema sin necesariamente cuestionarla. Sin embargo, esta estructura puede verse de forma mucho
más clara al ver la forma como un input esta estructurado, y a partir de esto, comprobar la
utilidad de cada parte del input. Entonces, tomemos como ejemplo el segundo test proveido por el
enunciado:
\begin{verbatim}
    3 
    3 5 8 7 3 4 11
    2 3 4 7 9 
    2 4 5 7 8 4
\end{verbatim}
Y de este input, tendríamos este output:
\begin{verbatim}
    True [(8,3),(7,4),(11)]
    False
    True [(5,7)(8,4)]
\end{verbatim}
Para entender el porque de este output, vamos a tomar el primer input de este
set de inputs:
\begin{verbatim}
    3 5 8 7 3 4 11
    True [(8,3),(7,4),(11)]
\end{verbatim}
La primera cosa a notar es que este input no tiene toda la lista que se pasa por
parámetro. Los dos primeros numeros de la lista se obvian porque \textbf{No representan
familias, sino otras variables que nos serán relevantes.} Especificamente, el primer valor
representa las \textit{k} instancias de CAD, que serán listas, y el segundo valor representa
las \textit{i} familias que existen dentro del sistema, cuyo numero de miembros es
el int que representan. Por lo tanto, el input se vería, una vez formateado, así:
\begin{align*}
    Input = \begin{cases}
        i = 5 \\
        k = 3 \\
        nums = [8, 7, 3, 4, 11]
    \end{cases}
\end{align*}
notese que \textit{i} coincide con la longitud de \textit{nums}, y \textit{k} coincide
con la cantidad de listas generadas en el output. Esto no es una coincidencia, y será muy
importante cuando hablemos del diseño de la solución, pero por ahora, limitemonos a pensar
en que esto cambia la forma en la que pensamos del concepto de CADS y familias, a listas Y
enteros, entonces cuando pensamos el problema, no nos centramos en el enunciado, sino en su 
abstracción, \textbf{si encontramos las \textit{k} tuplas de los valores de nums con suma igual,
resolveremos el problema.}

Para corroborar esto, vamos a tomar la lista del output y vamos a ordenarla
\begin{align*}
    output[1] &= [(8,3), (7,4), (11)] \\
    <suma (Aritmetica)> \\
    output[1] &= [\underset{11}{\underbrace{[3 + 8]}},
    \underset{11}{\underbrace{[7 + 4]}},
    \underset{11}{\underbrace{[11]}}]
\end{align*} 

Como es posible tomar la lista \textit{nums} y ponerla en \textit{k} tuplas de
sumas exactamente iguales, entonces el resultado es True, si no fuese posible, simplemente
se retornaría False, la estructura dinámica de Python y sus retornos nos permitirá hacer
de forma bastante sencilla la solución, pero nos estamos adelantando.

\subsection{Lectura de datos}
Según se nos fue informado por los monitores, la lectura se hará a partir de la lectura
de archivos de texto y, por lo tanto, la estructura del archivo de Python esta pensada para
poder leer varios archivos de texto secuencialmente.
%------------------------------------------------
\section{Diseño de la Solución}
\subsection{Conceptos Teóricos Importantes}
\subsubsection{Programación Dinámica}

\subsubsection{Memorización}
La Memorización se define cómo: 'a'[2]

\subsection{Conceptos Prácticos Importantes}
\subsubsection{Tipado dinámico}

\subsubsection{Return vacío}
%------------------------------------------------
\section{Análisis de la Solución}
\subsection{Complejidad}
\subsection{Limitantes}
\subsection{Consideraciones}
%------------------------------------------------
\section{Referencias.}
\begin{itemize}
    \item [1]: \textit{Enunciado del proyecto, ISIS 1105 Diseño y Análisis de Algoritmos
    Semestre 2023-10. Proyecto – PARTE 1} Uniandes, 2023.
    \item [2]: \textit{The Algorithm Design Manual, Springer}, Steven S. Skiena, .
\end{itemize}
\end{document}
