\documentclass[a4paper]{article} 
\input{head}
\begin{document}

%-------------------------------
%	TITLE SECTION
%-------------------------------

\fancyhead[C]{}
\hrule \medskip % Upper rule
\begin{minipage}{0.295\textwidth} 
\raggedright
\footnotesize
Jaime Andres Torres Bermejo \hfill\\   
202014866\hfill\\
andrestbermejoj@gmail.com
\end{minipage}
\begin{minipage}{0.4\textwidth} 
\centering 
\large 
Pre parcial 2\\ 
\normalsize 
Diseño y Análisis de Algoritmos\\ 
\end{minipage}
\begin{minipage}{0.295\textwidth} 
\raggedleft
\today\hfill\\
\end{minipage}
\medskip\hrule 
\bigskip

%-------------------------------
%	CONTENIDO
%-------------------------------
\section{Implemente todos los algoritmos vistos en clase y estudie su complejidad temporal.}
\subsection{DFS}
\begin{verbatim}
def dfs(Adj, s, visited): 
    visited[s] = True
    for n in Adj[s]:
        if not visited[n]:
        dfs(Adj,n,visited)
\end{verbatim}

\begin{itemize}
    \item Uso: Recorre todos los nodos de un grafo
    \item Complejidad: O(V+E)
    
\end{itemize}

\subsection{BFS}
\begin{verbatim}
def bfs(Adj, s): 
    visited = [False for v in Adj] 
    queue = [s]
    while 0 < len(queue): 
      current_node = queue.pop(0)
      if not visited[current_node]:
       # Usually here you do something 
       # with the current node
       visited[current_node] = True
       for n in Adj[current_node]:
         if not visited[n]:
           queue.append(n)
\end{verbatim}

\begin{itemize}
    \item Uso: Recorre todos los nodos de un grafo a partir de ir visitando los
    vecinos de un nodo concreto
    \item Complejidad: O(V+E)
    
\end{itemize}


\subsection{Dijkstra}
\begin{verbatim}
def dijkstra(graph, start, end):
    """Return the cost of the shortest path between vertices start and end.
    >>> dijkstra(G, "E", "C")
    6
    >>> dijkstra(G2, "E", "F")
    3
    >>> dijkstra(G3, "E", "F")
    3
    """

    heap = [(0, start)]  # cost from start node,end node
    visited = set()
    while heap:
        (cost, u) = heapq.heappop(heap)
        if u in visited:
            continue
        visited.add(u)
        if u == end:
            return cost
        for v, c in graph[u]:
            if v in visited:
                continue
            next_item = cost + c
            heapq.heappush(heap, (next_item, v))
    return -1
\end{verbatim}

\begin{itemize}
    \item Uso: Retorna el MST en el cuál se puede evidenciar el camino mas corto entre 2
    nodos y el costo de este.
    \item Complejidad: $O(V^2)$
    
\end{itemize}



\subsection{Floyd-Warshall}
\begin{verbatim}


    def _print_dist(dist, v):
    print("\nThe shortest path matrix using Floyd Warshall algorithm\n")
    for i in range(v):
        for j in range(v):
            if dist[i][j] != float("inf"):
                print(int(dist[i][j]), end="\t")
            else:
                print("INF", end="\t")
        print()


    def floyd_warshall(graph, v):
        """
        :param graph: 2D array calculated from weight[edge[i, j]]
        :type graph: List[List[float]]
        :param v: number of vertices
        :type v: int
        :return: shortest distance between all vertex pairs
        distance[u][v] will contain the shortest distance from vertex u to v.
        1. For all edges from v to n, distance[i][j] = weight(edge(i, j)).
        3. The algorithm then performs distance[i][j] = min(distance[i][j], distance[i][k] +
            distance[k][j]) for each possible pair i, j of vertices.
        4. The above is repeated for each vertex k in the graph.
        5. Whenever distance[i][j] is given a new minimum value, next vertex[i][j] is
            updated to the next vertex[i][k].
        """

        dist = [[float("inf") for _ in range(v)] for _ in range(v)]

        for i in range(v):
            for j in range(v):
                dist[i][j] = graph[i][j]

                # check vertex k against all other vertices (i, j)
        for k in range(v):
            # looping through rows of graph array
            for i in range(v):
                # looping through columns of graph array
                for j in range(v):
                    if (
                        dist[i][k] != float("inf")
                        and dist[k][j] != float("inf")
                        and dist[i][k] + dist[k][j] < dist[i][j]
                    ):
                        dist[i][j] = dist[i][k] + dist[k][j]

        _print_dist(dist, v)
        return dist, v


\end{verbatim}

\begin{itemize}
    \item Uso: Retorna el MST de un grafo.
    \item Complejidad: $O(V^3)$
    
\end{itemize}


%-------------------------------
\section{Explique cual es la complejidad temporal de los algoritmos vistos en clase: BFS,
Dijkstra, Bellman-Ford y Floyd-Warshall.}
\subsection{BFS}
Un algoritmo del tipo Breadth-First Search tiene una complejidad de $O(V+E)$, donde
'V' son los Vertices y 'E' son los arcos, esto se da debido a que sin importar cuáles
sean los valores, el algoritmo deberá poder acceder a todo el grafo para acabar su
ejecución. el punto es recorrer todo el grafo.

\subsection{Dijkstra}
Dado que este algoritmo retorna un camino de minimo costo entre dos nodos, garantizar
la existencia de este requiere recorrer todos los vertices del grafo por lo menos las
suficientes veces para garantizar el camino del nodo inicio al final. por lo que su complejidad es
$O(V^2)$

\subsection{Bellman-Ford}
La complejidad de Bellman Ford es $O(V*E)$, al igual que Dijkstra, nos permite recorrer
el MST de un grafo, sin embargo, este es un poco mas lento a cambio de poder procesar una
mayor cantidad de grafos. 

\subsection{Floyd Warshall}
La complejidad de Floyd Warshall es $O(V^3)$. nos garantiza el poder recorrer y conseguir
el MST de cualquier grafo a cambio de velocidad, de forma parecida a aquella del
Bellman-Ford.


%-------------------------------
\section{Explique por que el algoritmo de Dijkstra no funciona en un grafo que tiene arcos
negativos, de ser necesario puede usar un ejemplo para ilustrar su explicación.}

El algoritmo de Dijkstra no funciona en grafos con arcos negativos debido a que 
esta basado en una paradigma de solución Greedy, esta estrategia implica que el algoritmo
seleccionará la solución localmente óptima a la hora de ejecutarse. Al introducirse un ciclo negativo
en un algoritmo de este tipo, que inherentemente esta solamente preocupado por entregar una solución
inmediatamente menor, puede causar situaciones de este tipo:
    
\begin{verbatim}
      A
     / \
    /   \
   /     \
  5       2
 /         \
B--(-800)--  C

V={A,B,C} ; E = {(A,C,2), (A,B,5), (B,C,-800)}
\end{verbatim}

En este caso tenemos un ciclo negativo y podemos asumir que esta conectado a mas partes
del grafo,  Si quisieramos encontrar un camino de un nodo a otro, sería 
posible que dado lo negativa que es la conexión de B a C, un valor previamente calculado
que pasara por estos vertices no se pudiese recalcular dada la naturaleza miope
del algoritmo, lo cuál causaria que el resultado de el arbol que retorna un grafo con este
ciclo fuese incorrecto. Algoritmos de grafos dinámicos podrían hacer esta recalculación,
por lo que el algoritmo podría funcionar, en general, Dijkstra no sirve en grafos con
vértices negativos por esta razón.


%-------------------------------
\section{Note que si se tiene un grafo de tamaño n se puede ejecutar Dijkstra o Bellman-
Ford n veces y lograr el mismo resultado que Floyd-Warshall. Sabemos que
se obtiene el mismo resultado, sin embargo, este acercamiento es equivalente? la
complejidad temporal es la misma? la complejidad espacial?}

Todos estos 3 algoritmos, como explicamos anteriormente, nos devuelven el MST 
correspondiente a un grafo. Dependiendo del algoritmo concreto, van a variar los detalles concretos
del cómo se ejecute este proceso y de las limitaciónes que llegará a tener. Tengamos en cuenta entonces, 
que en orden de complejidad, aunque Dijkstra es el de, en teoría, menor complejidad, también es el algoritmo
de los acá presentados mas restringido en los datasets que puede afrontar. Por ejemplo, su limitación de 
solo aceptar pesos positivos ya de por si lo limíta dado lo expuesto en la respuesta a la pregunta 3.
A cambio, es mas rápido y puede darnos información mas específica sin modificaciones
requeridas. Lo que causa esta diferencia es principalmente el hecho de que estan planteados por paradigmas diferentes
de programación, con Dijkstra siendo un algoritmo cuya lógica esta basada en los algoritmos
Greedy, mientras Floyd Warshall y Bellman Ford son dinámicos, permitiendoles usar soluciones a 
subproblemas para poder calcular el MST, que resulta en una mayor complejidad al escalar el
problema. 


%-------------------------------
\section{Modifique el algoritmo de Floyd-Warshall de tal forma que sea posible construir
el camino mas corto de entre cualquier nodo del grafo. Se modifica la complejidad
espacial o temporal del algoritmo original?}



\subsection{Floyd-Warshall (Modificado)}
\begin{verbatim}
    def _print_dist(dist, v):
    print("\nThe shortest path matrix using Floyd Warshall algorithm\n")
    for i in range(v):
        for j in range(v):
            if dist[i][j] != float("inf"):
                print(int(dist[i][j]), end="\t")
            else:
                print("INF", end="\t")
        print()


    def floyd_warshall(graph, v):
        """
        :param graph: 2D array calculated from weight[edge[i, j]]
        :type graph: List[List[float]]
        :param v: number of vertices
        :type v: int
        :return: shortest distance between all vertex pairs
        distance[u][v] will contain the shortest distance from vertex u to v.
        1. For all edges from v to n, distance[i][j] = weight(edge(i, j)).
        3. The algorithm then performs distance[i][j] = min(distance[i][j], distance[i][k] +
            distance[k][j]) for each possible pair i, j of vertices.
        4. The above is repeated for each vertex k in the graph.
        5. Whenever distance[i][j] is given a new minimum value, next vertex[i][j] is
            updated to the next vertex[i][k].
        """

        dist = [[float("inf") for _ in range(v)] for _ in range(v)]

        for i in range(v):
            for j in range(v):
                dist[i][j] = graph[i][j]
                
                # check vertex k against all other vertices (i, j)
                for k in range(v):
                    # looping through rows of graph array
                    for i in range(v):
                        # looping through columns of graph array
                        for j in range(v):
                            if (
                                dist[i][k] != float("inf")
                                and dist[k][j] != float("inf")
                                and dist[i][k] + dist[k][j] < dist[i][j]
                            ):
                                dist[i][j] = dist[i][k] + dist[k][j]

        _print_dist(dist, v)
        return dist, v
\end{verbatim}

%-------------------------------
\section{Explique como el algoritmo de Floyd-Warshall puede detectar si el grafo original
tiene ciclos negativos. Algún otro de los algoritmos visto en clase permite lo mismo?}

El algoritmo de Floyd Warshall mantiene en memoria una tabla, generalmente llamada en literatura
'dist'. esta tabla lleva las distancias entre todos los nodos. Dado que sabemos que la diagonal
va a tener una distancia de 1 al ser configurado para la detección de ciclos
y que este algoritmo intenta minimizar las distancias, entonces podemos asumir que un resultado
menor dentro de esta diagonal implica la detección de un ciclo, pues se encontró una forma más
barata de entrar al propio grafo.


%-------------------------------
\section{Un grafo bipartito, es un grafo tal que el conjunto de nodos se puede expresar
como dos conjuntos disjuntos, de manera que no hay dos nodos del mismo conjunto
que sean adyacentes. Diseñe un algoritmo que reciba un grafo, en su implantación
indique si su grafo esta implementado como lista o matriz de adyacencia, y retorne
T rue si el grafo es bipartito y False en otro caso. La complejidad no debe superar
O(V*E), donde V es el conjunto de nodos y E el conjunto de arcos del grafo.}

\begin{verbatim}
def bipartito(adj_list):

\end{verbatim}


%-------------------------------
\section{Un grafo ponderado desconectado no tiene  árboles de expansión. Sin embargo, es
posible encontrar un bosque de expansión de peso mínimo en un grafo de este tipo.
Explique cómo modificar tanto el algoritmo de Kruskal como el algoritmo de Prim
para hacer esto.}

El algoritmo de prim y kruskal en estos casos funcionan como un grafo topológico, es
decir, un grafo donde la ponderación de sus entre sus ejes será la distancia euclidiana
entre los puntos. A partir de esta distancia, podemos empezar a conectar todo.

en otras palabras, para hacer que ambos prim o kruskal puedan calcular un árbol de
expansión, debemos introducir una forma de calcular distancias entre dos puntos, para
efectos de este curso generalmente 2d, esto puede hacerse puramente con implementación. Sin 
embargo, si se hace esto para todos los nodos dentro del grafo puede aumentar considerablemente
la complejidad de no ser que se implementase algún tipo de backtracking que pudiese
conectar todo el grafo revirtiendo modificaciones, cosa la cuál sinceramente no sabría 
evaluar en complejidad como una alternativa.

%-------------------------------
\section{Explique porque el flujo máximo se alcanza cuando la red residual no contiene
caminos de aumento.}



\end{document}
